



SUIT                                                            B. Moran
Internet-Draft                                               Arm Limited
Intended status: Standards Track                             K. Takayama
Expires: 27 April 2023                                   SECOM CO., LTD.
                                                         24 October 2022


          SUIT Manifest Extensions for Multiple Trust Domains
                    draft-ietf-suit-trust-domains-00

Abstract

   This specification describes extensions to the SUIT manifest format
   (as defined in [I-D.ietf-suit-manifest]) for use in deployments with
   multiple trust domains.  A device has more than one trust domain when
   it enables delegation of different rights to mutually distrustful
   entities for use with different purposes or components in the context
   of firmware update.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 27 April 2023.

Copyright Notice

   Copyright (c) 2022 IETF Trust and the persons identified as the
   document authors.  All rights reserved.











Moran & Takayama          Expires 27 April 2023                 [Page 1]

Internet-Draft             SUIT Trust Domains               October 2022


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
   2.  Conventions and Terminology . . . . . . . . . . . . . . . . .   3
   3.  Changes to SUIT Workflow Model  . . . . . . . . . . . . . . .   5
   4.  Changes to Manifest Metadata Structure  . . . . . . . . . . .   6
   5.  Delegation Chains . . . . . . . . . . . . . . . . . . . . . .   7
     5.1.  Delegation Chains . . . . . . . . . . . . . . . . . . . .   7
   6.  Dependencies  . . . . . . . . . . . . . . . . . . . . . . . .   7
     6.1.    Changes to Required Checks  . . . . . . . . . . . . . .   8
     6.2.  Changes to Manifest Structure . . . . . . . . . . . . . .   9
     6.3.  Changes to Abstract Machine Description . . . . . . . . .   9
     6.4.  Processing Dependencies . . . . . . . . . . . . . . . . .  10
       6.4.1.  Multiple Manifest Processors  . . . . . . . . . . . .  11
     6.5.  Dependency Resolution . . . . . . . . . . . . . . . . . .  12
     6.6.  Added and Modified Commands . . . . . . . . . . . . . . .  12
       6.6.1.  suit-directive-set-parameters . . . . . . . . . . . .  12
       6.6.2.  suit-directive-process-dependency . . . . . . . . . .  13
       6.6.3.  suit-condition-is-dependency  . . . . . . . . . . . .  13
       6.6.4.  suit-directive-unlink . . . . . . . . . . . . . . . .  13
     6.7.  SUIT_Dependencies Manifest Element  . . . . . . . . . . .  14
   7.  Uninstall . . . . . . . . . . . . . . . . . . . . . . . . . .  15
   8.  Creating Manifests  . . . . . . . . . . . . . . . . . . . . .  16
     8.1.  Dependency Template . . . . . . . . . . . . . . . . . . .  16
       8.1.1.  Composite Manifests . . . . . . . . . . . . . . . . .  17
     8.2.  Encrypted Manifest Template . . . . . . . . . . . . . . .  17
     8.3.  Operating on Multiple Components  . . . . . . . . . . . .  18
   9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  20
     9.1.  SUIT Command Sequences  . . . . . . . . . . . . . . . . .  20
     9.2.  SUIT Commands . . . . . . . . . . . . . . . . . . . . . .  20
   10. Security Considerations . . . . . . . . . . . . . . . . . . .  21
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  21
     11.1.  Normative References . . . . . . . . . . . . . . . . . .  21
     11.2.  Informative References . . . . . . . . . . . . . . . . .  22
   Appendix A.  A.  Full CDDL  . . . . . . . . . . . . . . . . . . .  22
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  24






Moran & Takayama          Expires 27 April 2023                 [Page 2]

Internet-Draft             SUIT Trust Domains               October 2022


1.  Introduction

   Devices that go beyond single-signer update require more complex
   rules for deploying firmware updates.  For example, devices may
   require:

   *  long-term trust anchors with a mechanism to delegate trust to
      short term keys.

   *  software components from multiple software signing authorities.

   *  a mechanism to remove an uneeded component

   *  single-object dependencies

   *  a partly encrypted manifest so that distribution does not reveal
      private information

   These mechanisms are not part of the core manifest specification, but
   they are needed for more advanced use cases, such as the architecture
   described in [I-D.ietf-teep-architecture].

   This specification extends the SUIT Manifest specification
   ([I-D.ietf-suit-manifest]).

2.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Additionally, the following terminology is used throughout this
   document:

   *  SUIT: Software Update for the Internet of Things, also the IETF
      working group for this standard.

   *  Payload: A piece of information to be delivered.  Typically
      Firmware for the purposes of SUIT.

   *  Resource: A piece of information that is used to construct a
      payload.

   *  Manifest: A manifest is a bundle of metadata about the firmware
      for an IoT device, where to find the firmware, and the devices to
      which it applies.



Moran & Takayama          Expires 27 April 2023                 [Page 3]

Internet-Draft             SUIT Trust Domains               October 2022


   *  Envelope: A container with the manifest, an authentication wrapper
      with cryptographic information protecting the manifest,
      authorization information, and severable elements (see: TBD).

   *  Update: One or more manifests that describe one or more payloads.

   *  Update Authority: The owner of a cryptographic key used to sign
      updates, trusted by Recipients.

   *  Recipient: The system, typically an IoT device, that receives and
      processes a manifest.

   *  Manifest Processor: A component of the Recipient that consumes
      Manifests and executes the commands in the Manifest.

   *  Component: An updatable logical block of the Firmware, Software,
      configuration, or data of the Recipient.

   *  Component Set: A group of interdependent Components that must be
      updated simultaneously.

   *  Command: A Condition or a Directive.

   *  Condition: A test for a property of the Recipient or its
      Components.

   *  Directive: An action for the Recipient to perform.

   *  Trusted Invocation: A process by which a system ensures that only
      trusted code is executed, for example secure boot or launching a
      Trusted Application.

   *  A/B images: Dividing a Recipient's storage into two or more
      bootable images, at different offsets, such that the active image
      can write to the inactive image(s).

   *  Record: The result of a Command and any metadata about it.

   *  Report: A list of Records.

   *  Procedure: The process of invoking one or more sequences of
      commands.

   *  Update Procedure: A procedure that updates a Recipient by fetching
      dependencies and images, and installing them.






Moran & Takayama          Expires 27 April 2023                 [Page 4]

Internet-Draft             SUIT Trust Domains               October 2022


   *  Invocation Procedure: A procedure in which a Recipient verifies
      dependencies and images, loading images, and invokes one or more
      image.

   *  Software: Instructions and data that allow a Recipient to perform
      a useful function.

   *  Firmware: Software that is typically changed infrequently, stored
      in nonvolatile memory, and small enough to apply to [RFC7228]
      Class 0-2 devices.

   *  Image: Information that a Recipient uses to perform its function,
      typically firmware/software, configuration, or resource data such
      as text or images.  Also, a Payload, once installed is an Image.

   *  Slot: One of several possible storage locations for a given
      Component, typically used in A/B image systems

   *  Abort: An event in which the Manifest Processor immediately halts
      execution of the current Procedure.  It creates a Record of an
      error condition.

3.  Changes to SUIT Workflow Model

   The use of the features presented for use with multiple trust domains
   requires some augmentation of the workflow presented in the SUIT
   Manifest specification ([I-D.ietf-suit-manifest]):

   One additional assumption is added for the Update Procedure:

   *  All dependency manifests should be present before any payload is
      fetched.

   One additional assumption is added to the Invocation Procedure:

   *  All dependencies must be validated prior to loading.

   Two steps are added to the expected installation workflow of a
   Recipient:

   1.  *Verify delegation chains*

   2.  Verify the signature of the manifest.

   3.  Verify the applicability of the manifest.

   4.  *Resolve dependencies.*




Moran & Takayama          Expires 27 April 2023                 [Page 5]

Internet-Draft             SUIT Trust Domains               October 2022


   5.  Fetch payload(s).

   6.  Install payload(s).

   In addition, when multiple manifests are used for an update, each
   manifest's steps occur in a lockstep fashion; all manifests have
   dependency resolution performed before any manifest performs a
   payload fetch, etc.

4.  Changes to Manifest Metadata Structure

   To accomodate the additional metadata needed to enable these
   features, the envelope and manifest have several new elements added.

   The Envelope gains two more elements: Delegation chains and
   Integrated Dependencies The Common metadata section in the Manifest
   also gains a list of dependencies.

   The new metadata structure is shown below.

   +-------------------------+
   | Envelope                |
   +-------------------------+
   | Delegation Chains       |
   | Authentication Block    |
   | Manifest           --------------> +------------------------------+
   | Severable Elements      |          | Manifest                     |
   | Human-Readable Text     |          +------------------------------+
   | COSWID                  |          | Structure Version            |
   | Integrated Dependencies |          | Sequence Number              |
   | Integrated Payloads     |          | Reference to Full Manifest   |
   +-------------------------+    +------ Common Structure             |
                                  | +---- Command Sequences            |
   +-------------------------+    | |   | Digests of Envelope Elements |
   | Common Structure        | <--+ |   +------------------------------+
   +-------------------------+      |
   | Dependency Indices      |      +-> +-----------------------+
   | Component IDs           |          | Command Sequence      |
   | Common Command Sequence ---------> +-----------------------+
   +-------------------------+          | List of ( pairs of (  |
                                        |   * command code      |
                                        |   * argument /        |
                                        |      reporting policy |
                                        | ))                    |
                                        +-----------------------+






Moran & Takayama          Expires 27 April 2023                 [Page 6]

Internet-Draft             SUIT Trust Domains               October 2022


5.  Delegation Chains

   Delegation Chains allow a Recipient to establish a chain of trust
   from a Trust Anchor to the signer of a manifest by validating
   delegation claims.  Each delegation claim is a [RFC8392] CBOR Web
   Tokens (CWTs).  The first claim in each list is signed by a Trust
   Anchor.  Each subsequent claim in a list is signed by the public key
   claimed in the preceding list element.  The last element in each list
   claims a public key that can be used to verify a signature in the
   Authentication Block (See Sectino 5.2 of [I-D.ietf-suit-manifest]).

   See Section 5.1 for more detail.

5.1.  Delegation Chains

   The suit-delegation element MAY carry one or more CBOR Web Tokens
   (CWTs) [RFC8392], with [RFC8747] cnf claims.  They can be used to
   perform enhanced authorization decisions.  The CWTs are arranged into
   a list of lists.  Each list starts with a CWT authorized by a Trust
   Anchor, and finishes with a key used to authenticate the Manifest
   (see Section 8.3 of [I-D.ietf-suit-manifest]).  This allows an Update
   Authority to delegate from a long term Trust Anchor, down through
   intermediaries, to a delegate without any out-of-band provisioning of
   Trust Anchors or intermediary keys.

   A Recipient MAY choose to cache intermediaries and/or delegates.  If
   an Update Distributor knows that a targeted Recipient has cached some
   intermediaries or delegates, it MAY choose to strip any cached
   intermediaries or delegates from the Delegation Chains in order to
   reduce bandwidth and energy.

6.  Dependencies

   A dependency is another SUIT_Envelope that describes additional
   components.

   Dependency manifests enable several additional use cases.  In
   particular, they enable two or more entities who are trusted for
   different privileges to coordinate.  This can be used in many
   scenarios, for example:

   *  An IoT device may contain a processor in its radio in addition to
      the primary processor.  These two processors may have separate
      firmware with separate signing authorities.  Dependencies allow
      the firmware for the primary processor to reference a manifest
      signed by a different authority.





Moran & Takayama          Expires 27 April 2023                 [Page 7]

Internet-Draft             SUIT Trust Domains               October 2022


   *  A network operator may wish to provide local caching of update
      payloads.  The network operator overrides the URI of payload by
      providing a dependent manifest that references the original
      manifest, but replaces its URI.

   *  A device operator provides a device with some additional
      configuration.  The device operator wants to test their
      configuration with each new firmware version before releasing it.
      The configuration is delivered as a binary in the same way as a
      firmware image.  The device operator references the firmware
      manifest from the firmware author in their own manifest which also
      defines the configuration.

   By using dependencies, components such as software, configuration,
   models, and other resources authenticated by different trust anchors
   can be delivered to devices.

6.1.    Changes to Required Checks

   This section augments the definitions in Required Checks
   (Section 6.2) of [I-D.ietf-suit-manifest].

   More checks are required when handling dependencies.  By default, any
   signature of a dependency MUST be verified.  However, there are some
   exceptions to this rule: where a device supports only one level of
   access (no ACLs defining which authorities have access to different
   components/commands/parameters), it MAY choose to skip signature
   verification of dependencies, since they are verified by digest.
   Where a device differentiates between trust levels, such as with an
   ACL, it MAY choose to defer the verification of signatures of
   dependencies until the list of affected components is known so that
   it can skip redundant signature verifications.  For example, if a
   dependent's signer has access rights to all components specified in a
   dependency, then that dependency does not require a signature
   verification.  Similarly, if the signer of the dependent has full
   rights to the device, according to the ACL, then no signature
   verification is necessary on the dependency.

   Components that should be treated as dependency manifests are
   identified in the suit-common metadata.  See section Section 6.2 for
   details.

   If the manifest contains more than one component and/or dependency,
   each command sequence MUST begin with a Set Component Index command.

   If a dependency is specified, then the manifest processor MUST
   perform the following checks:




Moran & Takayama          Expires 27 April 2023                 [Page 8]

Internet-Draft             SUIT Trust Domains               October 2022


   1.  The dependent MUST populate all command sequences for the current
       procedure (Update or Invoke).

   2.  At the end of each section in the dependent: The corresponding
       section in each dependency has been executed.

   If the interpreter does not support dependencies and a manifest
   specifies a dependency, then the interpreter MUST Abort.

   If a Recipient supports groups of interdependent components (a
   Component Set), then it SHOULD verify that all Components in the
   Component Set are specified by one update, that is: a single manifest
   and all its dependencies that together:

   1.  have sufficient permissions imparted by their signatures

   2.  specify a digest and a payload for every Component in the
       Component Set.

   The single dependent manifest is sometimes called a Root Manifest.

6.2.  Changes to Manifest Structure

   This section augments the Manifest Structure (Section 8.4) in
   [I-D.ietf-suit-manifest].

6.3.  Changes to Abstract Machine Description

   This section augments the Abstract Machine Description (Section 6.4)
   in [I-D.ietf-suit-manifest] With the addition of dependencies, some
   changes are necessary to the abstract machine, outside the typical
   scope of added commands.  These changes alter the behaviour of an
   existing command and way that the parser processes manifests:

   *  Two new commands are introduced.

      -  Process dependency.

      -  Is Dependency.

   *  Dependency manifests are also components.  All commands may target
      dependency manifests as well as components, with one exception:
      process dependency.  Commands defined outside of this draft and
      [I-D.ietf-suit-manifest] MAY have additional restrictions.







Moran & Takayama          Expires 27 April 2023                 [Page 9]

Internet-Draft             SUIT Trust Domains               October 2022


   *  Dependencies are processed in lock-step with the Root Manifest.
      This means that every dependency's current command sequence must
      be executed before a dependent's later command sequence may be
      executed.  For example, every dependency's Dependency Resolution
      step MUST be executed before any dependent's payload fetch step.

   *  When performing a suit-condition-image-match operation on a
      component, the manifest processor MUST first determine whether or
      not the component is a dependency manifest.  If identified as a
      dependency manifest envelope, the manifest processor MUST compute
      the digest over only the SUIT_Manifest bstr, not the complete
      SUIT_Manifest_Envelope.  This is so that severable elements, added
      or removed signatures, and delegations do not affect the integrity
      measurements of the manifest.

6.4.  Processing Dependencies

   As described in Section 6.1, each manifest must invoke each of its
   dependencies' sections from the corresponding section of the
   dependent.  Any changes made to parameters by the dependency persist
   in the dependent.

   When a Process Dependency command is encountered, the manifest
   processor:

   1.  Checks whether the map of dependencies contains an entry for the
       current Component Index.  If not present, it causes an immediate
       Abort.

   2.  Loads the specified component as a dependency manifest envelope.

   3.  Authenticates the dependency manifest

   4.  Executes the common-sequence section of the dependency manifest

   5.  Executes the section of the dependency manifest that corresponds
       to the currently executing section of the dependent.

   If the specified dependency does not contain the current section,
   Process Dependency succeeds immediately.

   The interpreter also performs the checks described in Section 6.1 to
   ensure that the dependent is processing the dependency correctly.








Moran & Takayama          Expires 27 April 2023                [Page 10]

Internet-Draft             SUIT Trust Domains               October 2022


6.4.1.  Multiple Manifest Processors

   When a system has multiple security domains, each domain might
   require independent verification of authenticity or security
   policies.  Security domains might be divided by separation technology
   such as Arm TrustZone, Intel SGX, or another TEE technology.
   Security domains might also be divided into separate processors and
   memory spaces, with a communication interface between them.

   For example, an application processor may have an attached
   communications module that contains a processor.  The communications
   module might require metadata signed by a specific Trust Authority
   for regulatory approval.  This may be a different Trust Authority
   than the application processor.

   When there are two or more security domains (see
   [I-D.ietf-teep-architecture]), a manifest processor might be required
   in each.  The first manifest processor is the normal manifest
   processor as described for the Recipient in Section 6 of
   [I-D.ietf-suit-manifest].  The second manifest processor only
   executes sections when the first manifest processor requests it.  An
   API interface is provided from the second manifest processor to the
   first.  This allows the first manifest processor to request a limited
   set of operations from the second.  These operations are limited to:
   setting parameters, inserting an Envelope, invoking a Manifest
   Command Sequence.  The second manifest processor declares a prefix to
   the first, which tells the first manifest processor when it should
   delegate to the second.  These rules are enforced by underlying
   separation of privilege infrastructure, such as TEEs, or physical
   separation.

   When the first manifest processor encounters a dependency prefix,
   that informs the first manifest processor that it should provide the
   second manifest processor with the corresponding dependency Envelope.
   This is done when the dependency is fetched.  The second manifest
   processor immediately verifies any authentication information in the
   dependency Envelope.  When a parameter is set for any component that
   matches the prefix, this parameter setting is passed to the second
   manifest processor via an API.  As the first manifest processor works
   through the Procedure (set of command sequences) it is executing,
   each time it sees a Process Dependency command that is associated
   with the prefix declared by the second manifest processor, it uses
   the API to ask the second manifest processor to invoke that
   dependency section instead.

   This mechanism ensures that the two or more manifest processors do
   not need to trust each other, except in a very limited case.  When
   parameter setting across security domains is used, it must be very



Moran & Takayama          Expires 27 April 2023                [Page 11]

Internet-Draft             SUIT Trust Domains               October 2022


   carefully considered.  Only parameters that do not have an effect on
   security properties should be allowed.  The dependency manifest MAY
   control which parameters are allowed to be set by using the Override
   Parameters directive.  The second manifest processor MAY also control
   which parameters may be set by the first manifest processor by means
   of an ACL that lists the allowed parameters.  For example, a URI may
   be set by a dependent without a substantial impact on the security
   properties of the manifest.

6.5.  Dependency Resolution

   The Dependency Resolution Command Sequence is a container for the
   commands needed to acquire and process the dependencies of the
   current manifest.  Ideally, all dependency manifests should be
   fetched before any payload is fetched to ensure that all manifests
   are available and authenticated before any of the (larger) payloads
   are acquired.

6.6.  Added and Modified Commands

   All commands are modified in that they can also target dependencies.
   However, Set Component Index has a larger modification.

          +================+====================================+
          | Command Name   | Semantic of the Operation          |
          +================+====================================+
          | Set Parameters | current.params[k] := v if not k in |
          |                | current.params for-each k,v in arg |
          +----------------+------------------------------------+
          | Process        | exec(current[common]);             |
          | Dependency     | exec(current[current-segment])     |
          +----------------+------------------------------------+
          | Is Dependency  | assert(current exists in           |
          |                | dependencies)                      |
          +----------------+------------------------------------+
          | Unlink         | unlink(current)                    |
          +----------------+------------------------------------+

                                  Table 1

6.6.1.  suit-directive-set-parameters

   Similarly to suit-directive-override-parameters, suit-directive-set-
   parameters allows the manifest to configure behavior of future
   directives by changing parameters that are read by those directives.
   Set Parameters is for use when dependencies are used because it
   allows a manifest to modify the behavior of its dependencies.




Moran & Takayama          Expires 27 April 2023                [Page 12]

Internet-Draft             SUIT Trust Domains               October 2022


   Available parameters are defined in [I-D.ietf-suit-manifest], section
   8.4.8.

   If a parameter is already set, suit-directive-set-parameters will
   skip setting the parameter to its argument.  This allows dependent
   manifests to change the behavior of a manifest, a dependency that
   wishes to enforce a specific value of a parameter MAY use suit-
   directive-override-parameters instead.

   suit-directive-set-parameters does not specify a reporting policy.

6.6.2.  suit-directive-process-dependency

   Execute the commands in the common section of the current dependency,
   followed by the commands in the equivalent section of the current
   dependency.  For example, if the current section is "fetch payload,"
   this will execute "common" in the current dependency, then "fetch
   payload" in the current dependency.  Once this is complete, the
   command following suit-directive-process-dependency will be
   processed.

   If the current component index does not have an entry in the suit-
   dependencies map, then this command MUST Abort.

   If the current component is True, then this directive applies to all
   dependencies.  If the current section is "common," then the command
   sequence MUST Abort.

   When SUIT_Process_Dependency completes, it forwards the last status
   code that occurred in the dependency.

6.6.3.  suit-condition-is-dependency

   Check whether or not the current component index is present in the
   dependency list.  If the current component is in the dependency list,
   suit-condition-is-dependency succeeds.  Otherwise, it fails.  This
   can be used along with component-id = True to act on all dependencies
   or on all non-dependency components.  See Section 8 for more details.

6.6.4.  suit-directive-unlink

   suit-directive-unlink applies to manifests.  When the components
   defined by a manifest are no longer needed, the manifest processor
   unlinks the manifest to inform the manifest processor that they are
   no longer needed.  The unlink command decrements an implementation-
   defined reference counter.  This reference counter MUST persist
   across restarts.  The reference counter MUST NOT be decremented by a
   given manifest more than once, and the manifest processor must



Moran & Takayama          Expires 27 April 2023                [Page 13]

Internet-Draft             SUIT Trust Domains               October 2022


   enforce this.  The manifest processor MAY choose to ignore a Unlink
   directive depending on device policy.

   When the reference counter reaches zero, the suit-uninstall command
   sequence is invoked (see Section 7).

   suit-directive-unlink is OPTIONAL to implement in manifest
   processors.

6.7.  SUIT_Dependencies Manifest Element

   Because some operations treat dependency manifests differently from
   other components, it is necessary to identify them.
   SUIT_Dependencies identifies which components from suit-components
   (See Section 8.4.5 of [I-D.ietf-suit-manifest]) are to be treated as
   dependency manifest envelopes.  SUIT_Dependencies is a map of
   Components, referenced by Component Index.  Optionally, a component
   prefix or other metadata may be delivered with the component index.
   The CDDL for suit-dependencies is shown below:

   SUIT_Dependencies = {
       + uint => SUIT_Dependency_Metadata
   }
   SUIT_Dependency_Metadata = {
       ? suit-dependency-prefix => SUIT_Component_Identifier
       $$SUIT_Dependency_Extensions
   }

   If no extended metadata is needed for an extension,
   SUIT_Dependency_Metadata is an empty map (this is the same encoding
   size as a null).  SUIT_Dependencies MUST be sorted according to CBOR
   canonical encoding.

   The components specified by SUIT_Dependency will contain a Manifest
   Envelope that describes a dependency of the current manifest.  The
   Manifest is identified, but the Recipient should expect an Envelope
   when it acquires the dependency.  This is because the Manifest is the
   one invariant element of the Envelope, where other elements may
   change by countersigning, adding authentication blocks, or severing
   elements.

   When executing suit-condition-image-match over a component that is
   designated in SUIT_Dependency, the digest MUST be computed over just
   the bstr-wrapped SUIT_Manifest contained in the Manifest Envelope
   designated by the Component Index.  This enables a dependency
   reference to uniquely identify a particular Manifest structure.  This
   is identical to the digest that is present as the first element of
   the suit-authentication-block in the dependency's Envelope.  The



Moran & Takayama          Expires 27 April 2023                [Page 14]

Internet-Draft             SUIT Trust Domains               October 2022


   digest is calculated over the Manifest structure to ensure that
   removing a signature from a manifest does not break dependencies due
   to missing signature elements.  This is also necessary to support the
   trusted intermediary use case, where an intermediary re-signs the
   Manifest, removing the original signature, potentially with a
   different algorithm, or trading COSE_Sign for COSE_Mac.

   The suit-dependency-prefix element contains a
   SUIT_Component_Identifier (see Section 8.4.5.1 of
   [I-D.ietf-suit-manifest]).  This specifies the scope at which the
   dependency operates.  This allows the dependency to be forwarded on
   to a component that is capable of parsing its own manifests.  It also
   allows one manifest to be deployed to multiple dependent Recipients
   without those Recipients needing consistent component hierarchy.
   This element is OPTIONAL for Recipients to implement.

   A dependency prefix can be used with a component identifier.  This
   allows complex systems to understand where dependencies need to be
   applied.  The dependency prefix can be used in one of two ways.  The
   first simply prepends the prefix to all Component Identifiers in the
   dependency.

   A dependency prefix can also be used to indicate when a dependency
   manifest needs to be processed by a secondary manifest processor, as
   described in Section 6.4.1.

7.  Uninstall

   In some systems, particularly with multiple, independent, optional
   components, it may be that there is a need to uninstall the
   components that have been installed by a manifest.  Where this is
   expected, the uninstall command sequence can provide the sequence
   needed to cleanly remove the components defined by the manifest and
   its dependencies.  In general, suit uninstall will contain primarily
   unlink directives.

   WARNING: This can cause faults where there are loose dependencies
   (e.g., version range matching, see
   [I-D.ietf-suit-update-management]), since a component can be removed
   while it is depended upon by another component.  To avoid dependency
   faults, a manifest author MAY use explicit dependencies where
   possible, or a manifest processor MAY track references to loose
   dependencies via reference counting in the same way as explicit
   dependencies, as described in Section 6.6.4.

   The Uninstall command sequence is not severable, since it must always
   be available to enable uninstalling.




Moran & Takayama          Expires 27 April 2023                [Page 15]

Internet-Draft             SUIT Trust Domains               October 2022


8.  Creating Manifests

   This section details a set of templates for creating manifests.
   These templates explain which parameters, commands, and orders of
   commands are necessary to achieve a stated goal.

8.1.  Dependency Template

   The goal of the Dependency template is to obtain, verify, and process
   a dependency manifest as appropriate.

   The following commands are added to the shared sequence:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for digest (see
      Section 8.4.8.6 of [I-D.ietf-suit-manifest]).  Note that the
      digest MUST match the SUIT_Digest in the dependency's suit-
      authentication-block (See Section 8.3 of
      [I-D.ietf-suit-manifest]).

   The following commands are placed into the dependency resolution
   sequence:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for URI (see
      Section 8.4.8.10 of [I-D.ietf-suit-manifest])

   *  Fetch directive (see Section 8.4.10.4 of [I-D.ietf-suit-manifest])

   *  Check Image Match condition (see Section 8.4.9.2 of
      [I-D.ietf-suit-manifest] of [I-D.ietf-suit-manifest])

   *  Process Dependency directive (see Section 6.6.2)

   Then, the validate sequence contains the following operations:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Check Image Match condition (see Section 8.4.9.2 of
      [I-D.ietf-suit-manifest])

   *  Process Dependency directive (see Section 6.6.2)




Moran & Takayama          Expires 27 April 2023                [Page 16]

Internet-Draft             SUIT Trust Domains               October 2022


   If any dependency is declared, the dependent MUST populate all
   command sequences for the current procedure (Update or Invoke).

   NOTE: Any changes made to parameters in a dependency persist in the
   dependent.

8.1.1.  Composite Manifests

   An implementer MAY choose to place a dependency's envelope in the
   envelope of its dependent.  The dependent envelope key for the
   dependency envelope MUST be a text string.  The URI for the
   dependency MUST match the text string key of the dependent's envelope
   key.  It is RECOMMENDED to make the text string key a resolvable URI
   so that a dependency manifest that is removed from the envelope can
   still be fetched.

8.2.  Encrypted Manifest Template

   The goal of the Encrypted Manifest template is to fetch and decrypt a
   manifest so that it can be used as a dependency.  To use an encrypted
   manifest, create a plaintext dependent, and add the encrypted
   manifest as a dependency.  The dependent can include very little
   information.

   NOTE: This template also requires the extensions defined in
   [I-D.ietf-suit-firmware-encryption]

   The following commands are added to the shared sequence:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for digest (see
      Section 8.4.8.6 of [I-D.ietf-suit-manifest]).  Note that the
      digest MUST match the SUIT_Digest in the dependency's suit-
      authentication-block (See Section 8.3 of
      [I-D.ietf-suit-manifest]).

   The following operations are placed into the dependency resolution
   block:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for

      -  URI (see Section 8.4.8.9 of [I-D.ietf-suit-manifest])




Moran & Takayama          Expires 27 April 2023                [Page 17]

Internet-Draft             SUIT Trust Domains               October 2022


      -  Encryption Info (See [I-D.ietf-suit-firmware-encryption])

   *  Fetch directive (see Section 8.4.10.4 of [I-D.ietf-suit-manifest])

   *  Check Image Match condition (see Section 8.4.9.2 of
      [I-D.ietf-suit-manifest])

   *  Process Dependency directive (see Section 6.6.2)

   Then, the validate block contains the following operations:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Check Image Match condition (see Section 8.4.9.2 of
      [I-D.ietf-suit-manifest])

   *  Process Dependency directive (see Section 6.6.2)

   A plaintext manifest and its encrypted dependency may also form a
   composite manifest (Section 8.1.1).

8.3.  Operating on Multiple Components

   In order to produce compact encoding, it is efficient to perform
   operations on multiple components simultaneously.  Because Dependency
   Manifests and Component Images are processed at different times,
   there is a mechanism to distinguish between these elements: suit-
   condition-is-manifest.  This can be used with suit-directive-try-each
   to perform operations just on Dependency Manifests or just on
   Component Images.

   For example, to fetch all dependency manifests, the following
   commands are added to the dependency resolution block:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for

      -  URI (see Section 8.4.8.9 of [I-D.ietf-suit-manifest])

   *  Set Component Index directive, with argument "True" (see
      Section 8.4.10.1 of [I-D.ietf-suit-manifest])

   *  Try Each Directive

      -  Sequence 0



Moran & Takayama          Expires 27 April 2023                [Page 18]

Internet-Draft             SUIT Trust Domains               October 2022


         o  Condition Is Manifest

         o  Fetch

         o  Condition Image Match

         o  Process Dependency

      -  Sequence 1 (Empty; no commands, succeeds immediately)

   Another example is to fetch and validate all Component Images.  The
   image fetch sequence contains the following commands:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for

      -  URI (see Section 8.4.8.9 of [I-D.ietf-suit-manifest])

   *  Set Component Index directive, with argument "True" (see
      Section 8.4.10.1 of [I-D.ietf-suit-manifest])

   *  Try Each Directive

      -  Sequence 0

         o  Condition Is Manifest

         o  Process Dependency

      -  Sequence 1 (Empty; no commands, succeeds immediately)

         o  Fetch

         o  Condition Image Match

   When some components are "installed" or "loaded" it is more
   productive to use lists of component indices rather than Component
   Index = True.  For example, to install several components, the
   following commands should be placed in the image install sequence:

   *  Set Component Index directive (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Set Parameters directive (see Section 6.6.1) for





Moran & Takayama          Expires 27 April 2023                [Page 19]

Internet-Draft             SUIT Trust Domains               October 2022


      -  Source Component (see Section 8.4.8.11 of
         [I-D.ietf-suit-manifest])

   *  Set Component Index directive, with argument containing list of
      destination component indices (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Copy

   *  Set Component Index directive, with argument containing list
      dependency component indices (see Section 8.4.10.1 of
      [I-D.ietf-suit-manifest])

   *  Process Dependency

9.  IANA Considerations

   IANA is requested to allocate the following numbers in the listed
   registries:

9.1.  SUIT Command Sequences

               +=======+=======================+===========+
               | Label | Name                  | Reference |
               +=======+=======================+===========+
               | 7     | Dependency Resolution |           |
               +-------+-----------------------+-----------+
               | 24    | Uninstall             | Section 7 |
               +-------+-----------------------+-----------+

                                  Table 2

9.2.  SUIT Commands

   +=======+============+===================================+=========+
   | Label | Name       | Reference                         |         |
   +=======+============+===================================+=========+
   | 7     | Is         | suit-directive-is-dependency      | Section |
   |       | Dependency |                                   | 6.6.3   |
   +-------+------------+-----------------------------------+---------+
   | 18    | Process    | suit-directive-process-dependency | Section |
   |       | Dependency |                                   | 6.6.2   |
   +-------+------------+-----------------------------------+---------+
   | 19    | Set        | Section 6.6.1                     |         |
   |       | Parameters |                                   |         |
   +-------+------------+-----------------------------------+---------+
   | 33    | Unlink     | Section 6.6.4                     |         |
   +-------+------------+-----------------------------------+---------+



Moran & Takayama          Expires 27 April 2023                [Page 20]

Internet-Draft             SUIT Trust Domains               October 2022


                                 Table 3

10.  Security Considerations

   This document is about a manifest format protecting and describing
   how to retrieve, install, and invoke firmware images and as such it
   is part of a larger solution for delivering firmware updates to IoT
   devices.  A detailed security treatment can be found in the
   architecture [RFC9019] and in the information model [RFC9124]
   documents.

11.  References

11.1.  Normative References

   [I-D.ietf-suit-manifest]
              Moran, B., Tschofenig, H., Birkholz, H., Zandberg, K., and
              O. Rønningstad, "A Concise Binary Object Representation
              (CBOR)-based Serialization Format for the Software Updates
              for Internet of Things (SUIT) Manifest", Work in Progress,
              Internet-Draft, draft-ietf-suit-manifest-20, 7 October
              2022, <https://www.ietf.org/archive/id/draft-ietf-suit-
              manifest-20.txt>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66,
              RFC 3986, DOI 10.17487/RFC3986, January 2005,
              <https://www.rfc-editor.org/info/rfc3986>.

   [RFC7228]  Bormann, C., Ersue, M., and A. Keranen, "Terminology for
              Constrained-Node Networks", RFC 7228,
              DOI 10.17487/RFC7228, May 2014,
              <https://www.rfc-editor.org/info/rfc7228>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8392]  Jones, M., Wahlstroem, E., Erdtman, S., and H. Tschofenig,
              "CBOR Web Token (CWT)", RFC 8392, DOI 10.17487/RFC8392,
              May 2018, <https://www.rfc-editor.org/info/rfc8392>.





Moran & Takayama          Expires 27 April 2023                [Page 21]

Internet-Draft             SUIT Trust Domains               October 2022


   [RFC8747]  Jones, M., Seitz, L., Selander, G., Erdtman, S., and H.
              Tschofenig, "Proof-of-Possession Key Semantics for CBOR
              Web Tokens (CWTs)", RFC 8747, DOI 10.17487/RFC8747, March
              2020, <https://www.rfc-editor.org/info/rfc8747>.

   [RFC9019]  Moran, B., Tschofenig, H., Brown, D., and M. Meriac, "A
              Firmware Update Architecture for Internet of Things",
              RFC 9019, DOI 10.17487/RFC9019, April 2021,
              <https://www.rfc-editor.org/info/rfc9019>.

   [RFC9124]  Moran, B., Tschofenig, H., and H. Birkholz, "A Manifest
              Information Model for Firmware Updates in Internet of
              Things (IoT) Devices", RFC 9124, DOI 10.17487/RFC9124,
              January 2022, <https://www.rfc-editor.org/info/rfc9124>.

11.2.  Informative References

   [I-D.ietf-suit-firmware-encryption]
              Tschofenig, H., Housley, R., Moran, B., Brown, D., and K.
              Takayama, "Encrypted Payloads in SUIT Manifests", Work in
              Progress, Internet-Draft, draft-ietf-suit-firmware-
              encryption-09, 24 October 2022,
              <https://www.ietf.org/archive/id/draft-ietf-suit-firmware-
              encryption-09.txt>.

   [I-D.ietf-suit-update-management]
              Moran, B., "Update Management Extensions for Software
              Updates for Internet of Things (SUIT) Manifests", Work in
              Progress, Internet-Draft, draft-ietf-suit-update-
              management-01, 24 October 2022,
              <https://www.ietf.org/archive/id/draft-ietf-suit-update-
              management-01.txt>.

   [I-D.ietf-teep-architecture]
              Pei, M., Tschofenig, H., Thaler, D., and D. M. Wheeler,
              "Trusted Execution Environment Provisioning (TEEP)
              Architecture", Work in Progress, Internet-Draft, draft-
              ietf-teep-architecture-18, 11 July 2022,
              <https://www.ietf.org/archive/id/draft-ietf-teep-
              architecture-18.txt>.

Appendix A.  A.  Full CDDL

   To be valid, the following CDDL MUST be appended to the SUIT Manifest
   CDDL.  The SUIT CDDL is defined in Appendix A of
   [I-D.ietf-suit-manifest]





Moran & Takayama          Expires 27 April 2023                [Page 22]

Internet-Draft             SUIT Trust Domains               October 2022


   $$SUIT_Envelope_Extensions //=
       (suit-delegation => bstr .cbor SUIT_Delegation)
   $$SUIT_Envelope_Extensions //= SUIT_Integrated_Dependency

   SUIT_Delegation = [ + [ + bstr .cbor CWT ] ]

   CWT = SUIT_Authentication_Block

   $$SUIT_severable-members-extensions //=
       (suit-dependency-resolution => bstr .cbor SUIT_Command_Sequence)

   $$unseverable-manifest-member-extensions //=
       (suit-uninstall => bstr .cbor SUIT_Command_Sequence)

   SUIT_Integrated_Dependency = (
       suit-integrated-dependency-key => bstr .cbor SUIT_Envelope)
   suit-integrated-dependency-key = tstr

   $$severable-manifest-members-choice-extensions //= (
       suit-dependency-resolution => \
           bstr .cbor SUIT_Command_Sequence / SUIT_Digest)

   $$SUIT_Common-extensions //= (
           suit-dependencies => SUIT_Dependencies
   )
   SUIT_Dependencies = {
       + uint => SUIT_Dependency_Metadata
   }
   SUIT_Dependency_Metadata = {
       ? suit-dependency-prefix => SUIT_Component_Identifier
       $$SUIT_Dependency_Extensions
   }

   SUIT_Condition //= (
       suit-condition-is-dependency, SUIT_Rep_Policy)

   SUIT_Directive //= (
       suit-directive-process-dependency, SUIT_Rep_Policy)
   SUIT_Directive //= (suit-directive-set-parameters,
       {+ SUIT_Parameters})
   SUIT_Directive //= (
       suit-directive-unlink, SUIT_Rep_Policy)

   suit-delegation = 1
   suit-dependency-resolution = 7
   suit-uninstall = 24

   suit-dependencies = 1



Moran & Takayama          Expires 27 April 2023                [Page 23]

Internet-Draft             SUIT Trust Domains               October 2022


   suit-dependency-prefix = 1

   suit-condition-is-dependency            = 7
   suit-directive-process-dependency       = 18
   suit-directive-set-parameters           = 19
   suit-directive-unlink                   = 33

Authors' Addresses

   Brendan Moran
   Arm Limited
   Email: brendan.moran.ietf@gmail.com


   Ken Takayama
   SECOM CO., LTD.
   Email: ken.takayama.ietf@gmail.com


































Moran & Takayama          Expires 27 April 2023                [Page 24]
